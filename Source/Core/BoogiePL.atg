
/*---------------------------------------------------------------------------
// BoogiePL -
//--------------------------------------------------------------------------*/

/*using System;*/
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Boogie;
using Microsoft.BaseTypes;
using Bpl = Microsoft.Boogie;


COMPILER BoogiePL

/*--------------------------------------------------------------------------*/

readonly Program Pgm;

readonly Expr dummyExpr;
readonly Cmd dummyCmd;
readonly Block dummyBlock;
readonly Bpl.Type dummyType;
readonly List<Expr> dummyExprSeq;
readonly TransferCmd dummyTransferCmd;
readonly StructuredCmd dummyStructuredCmd;

public static Program ParseLibrary(string libraryName)
{
  string libraryFileName = $"{libraryName}.bpl";
  Assembly asm = Assembly.GetExecutingAssembly();
  var resourceName = $"Core.{libraryFileName}";
  using Stream resourceStream = asm.GetManifestResourceStream(resourceName);
  Parse(new StreamReader(resourceStream), libraryFileName, new List<string>(), out Program program);
  return program;
}

///<summary>
///Returns the number of parsing errors encountered.  If 0, "program" returns as
///the parsed program.
///</summary>
public static int Parse(string filename, List<string> defines, out /*maybe null*/ Program program, bool useBaseName=false) /* throws System.IO.IOException */ {
  Contract.Requires(filename != null);
  Contract.Requires(Cce.NonNullElements(defines,true));

  if (filename == "stdin.bpl") {
    return Parse(Console.In, filename, defines, out program, useBaseName);
  } else
  {
    using FileStream stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
    return Parse(new StreamReader(stream), filename, defines, out program, useBaseName);
  }
}

public static int Parse(TextReader stream, string filename, List<string> defines, out /*maybe null*/ Program program, bool useBaseName=false) /* throws System.IO.IOException */
{
  var preprocessedSource = ParserHelper.Fill(stream, defines);
  return Parse(preprocessedSource, filename, out program, useBaseName);
}

public static int Parse(string s, string filename, out /*maybe null*/ Program program, bool useBaseName=false) /* throws System.IO.IOException */ {
  Contract.Requires(s != null);
  Contract.Requires(filename != null);

  byte[] buffer = Cce.NonNull(UTF8Encoding.Default.GetBytes(s));
  MemoryStream ms = new MemoryStream(buffer,false);
  Errors errors = new Errors();
  Scanner scanner = new Scanner(ms, errors, filename, useBaseName);

  Parser parser = new Parser(scanner, errors, false);
  parser.Parse();
  if (errors.count == 0)
  {
    program = parser.Pgm;
  }
  else
  {
    program = null;
  }
  return errors.count;
}

public Parser(Scanner scanner, Errors errors, bool disambiguation)
 : this(scanner, errors)
{
  // initialize readonly fields
  Pgm = new Program();
  dummyExpr = new LiteralExpr(Token.NoToken, false);
  dummyCmd = new AssumeCmd(Token.NoToken, dummyExpr);
  dummyBlock = new Block(Token.NoToken, "dummyBlock", new List<Cmd>(), new ReturnCmd(Token.NoToken));
  dummyType = new BasicType(Token.NoToken, SimpleType.Bool);
  dummyExprSeq = new List<Expr> ();
  dummyTransferCmd = new ReturnCmd(Token.NoToken);
  dummyStructuredCmd = new BreakCmd(Token.NoToken, null);
}

// Class to represent the bounds of a bitvector expression t[a:b].
// Objects of this class only exist during parsing and are directly
// turned into BvExtract before they get anywhere else
private class BvBounds : Expr {
  public BigNum Lower;
  public BigNum Upper;
  public BvBounds(IToken tok, BigNum lower, BigNum upper)
    : base(tok, /*immutable=*/ false) {
    Contract.Requires(tok != null);
    this.Lower = lower;
    this.Upper = upper;
  }
  public override Bpl.Type ShallowType { get {Contract.Ensures(Contract.Result<Bpl.Type>() != null); return Bpl.Type.Int; } }
  public override void Resolve(ResolutionContext rc) {
    rc.Error(this, "bitvector bounds in illegal position");
  }
  public override void Emit(TokenTextWriter stream,
                            int contextBindingStrength, bool fragileContext) {
    Contract.Assert(false);throw new Cce.UnreachableException();
  }
  public override void ComputeFreeVariables(GSet<object> freeVars) { Contract.Assert(false);throw new Cce.UnreachableException(); }

  public override int ContentHash => throw new NotSupportedException("Not supported since this type is translated away");

  public override int ComputeHashCode()
  {
    return base.GetHashCode();
  }
}

/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  hexdigit = "0123456789ABCDEFabcdef".
  special = "'~#$^_.?`".
  glyph = "`~!@#$%^&*()-_=+[{]}|;:',<.>/?\\".

  cr        = '\r'.
  lf        = '\n'.
  tab       = '\t'.

  space = ' '.
  quote = '"'.

  newLine = cr + lf.
  regularStringChar = ANY - quote - newLine.

  nondigit = letter + special.
  nonquote = letter + digit + space + glyph.


/*------------------------------------------------------------------------*/
TOKENS
  ident =  [ '\\' ] nondigit {nondigit | digit}.
  bvlit = digit {digit} 'b' 'v' digit {digit}.
  digits = digit {digit}.

  string = quote { regularStringChar | "\\\"" } quote.

  decimal = digit {digit} 'e' [ '-' ] digit {digit} .
  dec_float = digit {digit} '.' digit {digit} [ 'e' [ '-' ] digit {digit} ] .
	float = [ '-' ] '0' 'x' hexdigit {hexdigit} '.' hexdigit {hexdigit} 'e' [ '-' ] digit {digit} 'f' digit {digit} 'e' digit {digit}
										| '0' 'N' 'a' 'N' digit {digit} 'e' digit {digit}
										| '0' 'n' 'a' 'n' digit {digit} 'e' digit {digit}
										| '0' '+' 'o' 'o' digit {digit} 'e' digit {digit}
										| '0' '-' 'o' 'o' digit {digit} 'e' digit {digit} .

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab


/*------------------------------------------------------------------------*/
PRODUCTIONS


/*------------------------------------------------------------------------*/
BoogiePL
= (. List<Variable> vs;
     List<Declaration> ds;
     Axiom ax;
     List<Declaration> ts;
     DatatypeTypeCtorDecl dt;
     YieldInvariantDecl yi;
     ActionDecl ac;
     YieldProcedureDecl yp;
     Procedure pr;
     Implementation im;
     Implementation nnim;
     bool isPure = false;
  .)
  { Consts<out ds>             (. foreach(Bpl.Declaration v in ds){
                                    Contract.Assert(v != null);
                                    Pgm.AddTopLevelDeclaration(v);
                                  }
                               .)
  | Function<out ds>           (. foreach(Bpl.Declaration d in ds){
                                    Contract.Assert(d != null);
                                    Pgm.AddTopLevelDeclaration(d);
                                  }
                               .)
  | Axiom<out ax>              (. Pgm.AddTopLevelDeclaration(ax); .)
  | UserDefinedTypes<out ts>   (. foreach(Declaration td in ts){
                                    Contract.Assert(td != null);
                                    Pgm.AddTopLevelDeclaration(td);
                                  }
                               .)
  | Datatype<out dt>           (. Pgm.AddTopLevelDeclaration(dt); .)
  | GlobalVars<out vs>         (. foreach(Bpl.Variable v in vs){
                                    Contract.Assert(v != null);
                                    Pgm.AddTopLevelDeclaration(v);
                                  }
                               .)
  | "yield" 
    (
      YieldInvariantDecl<out yi> (. Pgm.AddTopLevelDeclaration(yi); .)
    | YieldProcedureDecl<out yp, out im>     
                               (. Pgm.AddTopLevelDeclaration(yp);
                                  if (im != null) {
                                    Pgm.AddTopLevelDeclaration(im);
                                  }
                               .)
    )
  | Pure<ref isPure>
    (
      Procedure<isPure, out pr, out im>
                                (. Pgm.AddTopLevelDeclaration(pr);
                                   if (im != null) {
                                     Pgm.AddTopLevelDeclaration(im);
                                   }
                                   isPure = false;
                                .)
    | ActionDecl<isPure, out ac, out im, out dt>
                                       (. Pgm.AddTopLevelDeclaration(ac);
                                          if (im != null) {
                                            Pgm.AddTopLevelDeclaration(im);
                                          }
                                          if (dt != null) {
                                            Pgm.AddTopLevelDeclaration(dt);
                                          }
                                          isPure = false;
                                       .)
    )
  | Implementation<out nnim>   (. Pgm.AddTopLevelDeclaration(nnim); .)
  }
  EOF
  .

/*------------------------------------------------------------------------*/
GlobalVars<.out List<Variable> ds.>
= (.
    Contract.Ensures(Contract.ValueAtReturn(out ds) != null);
    QKeyValue kv = null;
    ds = new List<Variable>();
    var dsx = ds;
  .)
  "var"
  { Attribute<ref kv> }
  IdsTypeWheres<true, "global variables", delegate(TypedIdent tyd) { dsx.Add(new GlobalVariable(tyd.tok, tyd, kv)); } > ";"
  .

LocalVars<.List<Variable> ds.>
= (.
    Contract.Ensures(Contract.ValueAtReturn(out ds) != null);
    QKeyValue kv = null;
  .)
  "var"
  { Attribute<ref kv> }
  IdsTypeWheres<true, "local variables", delegate(TypedIdent tyd) { ds.Add(new LocalVariable(tyd.tok, tyd, kv)); } > ";"
  .

ProcFormals<.bool incoming, bool allowWhereClauses, out List<Variable> ds.>
= (. Contract.Ensures(Contract.ValueAtReturn(out ds) != null);
     ds = new List<Variable>();
     var dsx = ds;
     var context = allowWhereClauses ? "procedure formals" : "the 'implementation' copies of formals";
  .)
  "("
  [ AttributesIdsTypeWheres<allowWhereClauses, context, delegate(TypedIdent tyd, QKeyValue kv) { dsx.Add(new Formal(tyd.tok, tyd, incoming, kv)); }>
  ]
  ")"
  .

BoundVars<.out List<Variable> ds.>
= (.
    Contract.Ensures(Contract.ValueAtReturn(out ds) != null);
    List<TypedIdent> tyds = new List<TypedIdent>();
    ds = new List<Variable>();
    var dsx = ds;
  .)
  AttributesIdsTypeWheres<false, "bound variables", delegate(TypedIdent tyd, QKeyValue kv) { dsx.Add(new BoundVariable(tyd.tok, tyd, kv)); } >
  .

/*------------------------------------------------------------------------*/
/* IdsType is used with const declarations */
IdsType<.out List<TypedIdent> tyds.>
= (. Contract.Ensures(Contract.ValueAtReturn(out tyds) != null); List<IToken> ids;  Bpl.Type ty; .)
  Idents<out ids> ":" Type<out ty>
  (. tyds = new List<TypedIdent>();
     foreach(Token id in ids){
       Contract.Assert(id != null);
       tyds.Add(new TypedIdent(id, id.val, ty, null));
     }
  .)
  .

/* AttributesIdsTypeWheres is used with the declarations of formals and bound variables */
AttributesIdsTypeWheres<. bool allowWhereClauses, string context, System.Action<TypedIdent, QKeyValue> action .>
=
  AttributesIdsTypeWhere<allowWhereClauses, context, action>
  { "," AttributesIdsTypeWhere<allowWhereClauses, context, action> }
  .

IdsTypeWheres<. bool allowWhereClauses, string context, System.Action<TypedIdent> action .>
=
  IdsTypeWhere<allowWhereClauses, context, action>
  { "," IdsTypeWhere<allowWhereClauses, context, action> }
  .

AttributesIdsTypeWhere<. bool allowWhereClauses, string context, System.Action<TypedIdent, QKeyValue> action .>
= (. QKeyValue kv = null; .)
  { Attribute<ref kv> }
  IdsTypeWhere<allowWhereClauses, context, delegate(TypedIdent tyd) { action(tyd, kv); }>
  .

/* context is allowed to be null if allowWhereClauses is true */
IdsTypeWhere<. bool allowWhereClauses, string context, System.Action<TypedIdent> action .>
= (. List<IToken> ids;  Bpl.Type ty;  Expr wh = null;  Expr nne; .)
  Idents<out ids> ":" Type<out ty>
  [ "where" Expression<out nne>  (. if (!allowWhereClauses) {
                                      this.SemErr("where clause not allowed on " + context);
                                    } else {
                                      wh = nne;
                                    }
                                 .)
  ]
  (. foreach(Token id in ids){
       Contract.Assert(id != null);
       action(new TypedIdent(id, id.val, ty, wh));
     }
  .)
  .

/*------------------------------------------------------------------------*/
Type<out Bpl.Type ty>
= (.Contract.Ensures(Contract.ValueAtReturn(out ty) != null); IToken tok; ty = dummyType; .)
  (
    TypeAtom<out ty>
  |
    Ident<out tok>       (. List<Bpl.Type> args = new List<Bpl.Type> (); .)
    [ TypeArgs<args> ]   (. ty = new UnresolvedTypeIdentifier (tok, tok.val, args); .)
  |
    MapType<out ty>
  )
  .

TypeArgs<.List<Bpl.Type> ts.>
= (.Contract.Requires(ts != null); IToken tok; Bpl.Type ty; .)
  (
    TypeAtom<out ty>     (. ts.Add(ty); .)
    [ TypeArgs<ts> ]
  |
    Ident<out tok>       (. List<Bpl.Type> args = new List<Bpl.Type> ();
                            ts.Add(new UnresolvedTypeIdentifier (tok, tok.val, args)); .)
    [ TypeArgs<ts> ]
  |
    MapType<out ty>      (. ts.Add(ty); .)
  )
  .

TypeAtom<out Bpl.Type ty>
= (.Contract.Ensures(Contract.ValueAtReturn(out ty) != null); ty = dummyType; .)
  ( "int"              (. ty = new BasicType(t, SimpleType.Int); .)
  | "real"             (. ty = new BasicType(t, SimpleType.Real); .)
  | "bool"             (. ty = new BasicType(t, SimpleType.Bool); .)
  /* note: bitvectors and floats are handled in UnresolvedTypeIdentifier */
  |
  "("
  Type<out ty>
  ")"
  )
  .

MapType<out Bpl.Type ty>
= (.Contract.Ensures(Contract.ValueAtReturn(out ty) != null); IToken tok = null;
     IToken nnTok;
     List<Bpl.Type> arguments = new List<Bpl.Type>();
     Bpl.Type result;
     List<TypeVariable> typeParameters = new List<TypeVariable>();
   .)
  [ TypeParams<out nnTok, out typeParameters> (. tok = nnTok; .) ]
  "["                                         (.  if (tok == null) tok = t;  .)
    [ Types<arguments> ]
  "]"
  Type<out result>
  (.
    ty = new MapType(tok, typeParameters, arguments, result);
  .)
  .

TypeParams<.out IToken tok, out List<TypeVariable> typeParams.>
= (.Contract.Ensures(Contract.ValueAtReturn(out tok) != null); Contract.Ensures(Contract.ValueAtReturn(out typeParams) != null); List<IToken> typeParamToks; .)
  "<"    (.  tok = t;  .)
    Idents<out typeParamToks>
  ">"
  (.
    typeParams = new List<TypeVariable> ();
    foreach(Token id in typeParamToks){
      Contract.Assert(id != null);
      typeParams.Add(new TypeVariable(id, id.val));}
   .)
  .

Types<.List<Bpl.Type> ts.>
= (. Contract.Requires(ts != null); Bpl.Type ty; .)
  Type<out ty>                 (. ts.Add(ty); .)
  { "," Type<out ty>           (. ts.Add(ty); .)
  }
  .


/*------------------------------------------------------------------------*/
Consts<.out List<Declaration> ds.>
= (. Contract.Ensures(Contract.ValueAtReturn(out ds) != null); IToken y; List<TypedIdent> xs;
     ds = new List<Declaration>();
     var axioms = new List<Axiom>();
     Axiom axiom;
     bool u = false; QKeyValue kv = null; .)
  "const"                 (. y = t; .)
  { Attribute<ref kv> }
  [ "unique"              (. u = true;  .)
  ]
  IdsType<out xs>
  ( ";" | "uses" "{" { Axiom<out axiom>(. axioms.Add(axiom); ds.Add(axiom); .) } "}")
  (.
     foreach(TypedIdent x in xs){
       Contract.Assert(x != null);
       var constant = new Constant(y, x, u, kv, axioms);
       ds.Add(constant);
     }
  .)
  .

/*------------------------------------------------------------------------*/
Function<.out List<Declaration> ds.>
= (. Contract.Ensures(Contract.ValueAtReturn(out ds) != null);
     ds = new List<Declaration>(); IToken z;
     IToken typeParamTok;
     var typeParams = new List<TypeVariable>();
     var arguments = new List<Variable>();
     var axioms = new List<Axiom>();
     TypedIdent tyd;
     TypedIdent retTyd = null;
     Bpl.Type retTy;
     QKeyValue argKv = null;
     QKeyValue kv = null;
     Expr definition = null;
     Expr tmp;
     Axiom ax;
     bool revealed = false;
  .)
  [ "revealed"                         (. revealed = true; .) 
  ]
  "function" { Attribute<ref kv> } Ident<out z>
  [ TypeParams<out typeParamTok, out typeParams> ]
  "("
  [ VarOrType<out tyd, out argKv>      (. arguments.Add(new Formal(tyd.tok, tyd, true, argKv)); .)
  { "," VarOrType<out tyd, out argKv>  (. arguments.Add(new Formal(tyd.tok, tyd, true, argKv)); .)
  } ] ")"
  (. argKv = null; .)
  (
    "returns" "(" VarOrType<out retTyd, out argKv> ")"
    |
    ":" Type<out retTy>   (. retTyd = new TypedIdent(retTy.tok, TypedIdent.NoName, retTy); .)
  )
  ( "{" Expression<out tmp> (. definition = tmp; .) "}" [ "uses" "{" { Axiom<out ax>(. axioms.Add(ax); .) } "}" ]
  | "uses" "{" { Axiom<out ax>(. axioms.Add(ax); .) } "}"
  | ";"
  )
  (.
    if (retTyd == null) {
      // construct a dummy type for the case of syntax error
      retTyd = new TypedIdent(t, TypedIdent.NoName, new BasicType(t, SimpleType.Int));
    }
    Function func = new Function(z, z.val, typeParams, arguments,
                                      new Formal(retTyd.tok, retTyd, false, argKv), null, kv);
    func.AlwaysRevealed = revealed;
    foreach(var axiom in axioms) {
        ds.Add(axiom);
        func.OtherDefinitionAxioms.Add(axiom);
    }

    Contract.Assert(func != null);
    ds.Add(func);
    bool allUnnamed = true;
    foreach(Formal f in arguments) {
      Contract.Assert(f != null);
      if (f.TypedIdent.HasName) {
        allUnnamed = false;
        break;
      }
    }
    if (!allUnnamed) {
      Bpl.Type prevType = null;
      for (int i = arguments.Count; 0 <= --i; ) {
        TypedIdent curr = Cce.NonNull(arguments[i]).TypedIdent;
        if (curr.HasName) {
          // the argument was given as both an identifier and a type
          prevType = curr.Type;
        } else {
          // the argument was given as just one "thing", which syntactically parsed as a type
          if (prevType == null) {
            this.errors.SemErr(curr.tok, "the type of the last parameter is unspecified");
            break;
          }
          Bpl.Type ty = curr.Type;
          var uti = ty as UnresolvedTypeIdentifier;
          if (uti != null && uti.Arguments.Count == 0) {
            // the given "thing" was just an identifier, so let's use it as the name of the parameter
            curr.Name = uti.Name;
            curr.Type = prevType;
          } else {
            this.errors.SemErr(curr.tok, "expecting an identifier as parameter name");
          }
        }
      }
    }
    if (definition != null) {
      // generate either an axiom or a function body
      if (kv.FindBoolAttribute("inline")) {
        if (kv.FindBoolAttribute("define"))
          SemErr("function cannot have both :inline and :define attributes");
        func.Body = definition;
      } else if (kv.FindBoolAttribute("define")) {
        if (func.TypeParameters.Count > 0)
          SemErr("function with :define attribute has to be monomorphic");
        func.DefinitionBody = func.CreateFunctionDefinition(definition);
      } else {
        ds.Add(func.CreateDefinitionAxiom(definition, kv));
      }
    }
  .)
  .

VarOrType<out TypedIdent tyd, out QKeyValue kv>
= (.
    Contract.Ensures(Contract.ValueAtReturn(out tyd) != null);
    string varName = TypedIdent.NoName;
    Bpl.Type ty;
    IToken tok;
    kv = null;
  .)
  { Attribute<ref kv> }
  Type<out ty>    (. tok = ty.tok; .)
  [ ":"           (. var uti = ty as UnresolvedTypeIdentifier;
                     if (uti != null && uti.Arguments.Count == 0) {
                       varName = uti.Name;
                     } else {
                       this.SemErr("expected identifier before ':'");
                     }
                  .)
    Type<out ty>
  ]
  (. tyd = new TypedIdent(tok, varName, ty); .)
  .

/*------------------------------------------------------------------------*/
Axiom<out Axiom m>
= (.
    Contract.Ensures(Contract.ValueAtReturn(out m) != null); 
    Expr e; 
    QKeyValue kv = null; 
    bool canHide = false; .)
  [ "hideable" (. canHide = true; .) ]
  "axiom"
   { Attribute<ref kv> }
   (. IToken x = t; .)
  Proposition<out e> ";"  (. m = new Axiom(x,e, null, kv, canHide); .)
  .

/*------------------------------------------------------------------------*/
UserDefinedTypes<.out List<Declaration> ts.>
= (. Contract.Ensures(Cce.NonNullElements(Contract.ValueAtReturn(out ts))); Declaration decl; QKeyValue kv = null; ts = new List<Declaration> (); .)
  "type"
  { Attribute<ref kv> }
  UserDefinedType<out decl, kv>          (.  ts.Add(decl);  .)
  { "," UserDefinedType<out decl, kv>    (.  ts.Add(decl);  .) }
  ";"
  .

UserDefinedType<out Declaration decl, QKeyValue kv>
= (. Contract.Ensures(Contract.ValueAtReturn(out decl) != null); IToken id; List<IToken> paramTokens = new List<IToken> ();
     Bpl.Type body = dummyType; bool synonym = false; .)
  Ident<out id>
  [ WhiteSpaceIdents<out paramTokens> ]
  [
    "=" Type<out body>
    (. synonym = true; .)
  ]
  (.
     if (synonym) {
       List<TypeVariable> typeParams = new List<TypeVariable>();
       foreach(Token t in paramTokens){
         Contract.Assert(t != null);
         typeParams.Add(new TypeVariable(t, t.val));}
       decl = new TypeSynonymDecl(id, id.val, typeParams, body, kv);
     } else {
       decl = new TypeCtorDecl(id, id.val, paramTokens.Count, kv);
     }
   .)
  .

/*------------------------------------------------------------------------*/
Datatype<out DatatypeTypeCtorDecl datatypeTypeCtorDecl>
= (. QKeyValue kv = null; IToken typeParamTok, name; List<TypeVariable> typeParams = new List<TypeVariable>(); .)
  "datatype"
  { Attribute<ref kv> }
  Ident<out name>
  [ TypeParams<out typeParamTok, out typeParams> ]
  (. datatypeTypeCtorDecl = new DatatypeTypeCtorDecl(name, name.val, typeParams, kv); .)
  "{"
    Constructors<datatypeTypeCtorDecl>
  "}"
  .

Constructors<DatatypeTypeCtorDecl datatypeTypeCtorDecl>
=
  Constructor<datatypeTypeCtorDecl>
  {
    ","
    Constructor<datatypeTypeCtorDecl>
  }
  .

Constructor<DatatypeTypeCtorDecl datatypeTypeCtorDecl>
= (. IToken name; List<Variable> fields = new List<Variable>(); .)
  Ident<out name>
  "("
  [ AttributesIdsTypeWheres<false, "datatype constructor", delegate(TypedIdent ti, QKeyValue kv) { fields.Add(new Formal(ti.tok, ti, true, kv)); }> ]
  ")"
  (.
    if (!datatypeTypeCtorDecl.AddConstructor(name, name.val, fields)) {
      this.SemErr($"constructor name {name.val} used more than once in datatype");
    }
  .)
  .

/*------------------------------------------------------------------------*/
YieldInvariantDecl<out YieldInvariantDecl yieldInvariant>
= (. List<Requires> invariants = new List<Requires>(); QKeyValue kv = null; IToken name = null; List<Variable> ins; .)
  "invariant"
  { Attribute<ref kv> }
  Ident<out name>
  ProcFormals<true, true, out ins> ";"
  { Invariant<invariants> }
  (. yieldInvariant = new YieldInvariantDecl(name, name.val, ins, invariants, kv); .)
  .

Invariant<.List<Requires> invariants.>
= (. Expr e; IToken tok = null; QKeyValue kv = null; .)
  ( "invariant"              (. tok = t; .)
    { Attribute<ref kv> }
    Proposition<out e> ";"  (. invariants.Add(new Requires(tok, false, e, null, kv)); .)
  )
  .

Pure<ref bool isPure>
= ["pure" (. isPure = true; .)]
  .

ActionDecl<bool isPure, out ActionDecl actionDecl, out Implementation impl, out DatatypeTypeCtorDecl datatypeTypeCtorDecl>
= (. IToken name = null;
     bool isAsync = false;
     MoverType moverType = MoverType.None;
     List<Variable> ins, outs = new List<Variable>();
     List<IdentifierExpr> mods = new List<IdentifierExpr>();
     List<ActionDeclRef> creates = new List<ActionDeclRef>();
     ActionDeclRef refinedAction = null;
     ActionDeclRef invariantAction = null;
     List<Requires> requires = new List<Requires>();
     List<CallCmd> yieldRequires = new List<CallCmd>();
     List<AssertCmd> asserts = new List<AssertCmd>();
     List<Variable> locals;
     StmtList stmtList;
     QKeyValue kv = null;
     datatypeTypeCtorDecl = null;
     impl = null;
   .)
  [ "async" (. isAsync = true; .) ]
  [ MoverQualifier<ref moverType> ]
  "action"
  { Attribute<ref kv> }
  Ident<out name>
  ProcFormals<true, true, out ins>
    [ "returns" ProcFormals<false, true, out outs> ]
  ( ";"
    { SpecAction<ref refinedAction, ref invariantAction, mods, creates, requires, yieldRequires, asserts> }
  | { SpecAction<ref refinedAction, ref invariantAction, mods, creates, requires, yieldRequires, asserts> }
    ImplBody<out locals, out stmtList>
    (.
       impl = new Implementation(name, name.val, new List<TypeVariable>(), Formal.StripWhereClauses(ins), Formal.StripWhereClauses(outs),
                                      locals, stmtList, kv == null ? null : (QKeyValue)kv.Clone());
    .)
  )
  (.
     if (isPure) {
       if (moverType == MoverType.None)
       {
         moverType = MoverType.Both;
       }
       else
       {
         this.SemErr("mover type unnecessary for pure action since it is a both mover");
       }
     }
     if (isAsync) {
       if (outs.Count > 0)
       {
         this.SemErr("async action must not have output parameters");
       }
       else
       {
         if (moverType == MoverType.None)
         {
           moverType = MoverType.Atomic;
         }
         datatypeTypeCtorDecl = new DatatypeTypeCtorDecl(name, name.val, new List<TypeVariable>(), null);
         var fields = ins.Select(v => new Formal(v.tok, new TypedIdent(v.TypedIdent.tok, v.Name, v.TypedIdent.Type), true, v.Attributes)).ToList<Variable>();
         datatypeTypeCtorDecl.AddConstructor(name, name.val, fields);
       }
     }
     actionDecl = new ActionDecl(name, name.val, moverType, ins, outs, isPure, creates, refinedAction, invariantAction, requires, yieldRequires, asserts, mods, datatypeTypeCtorDecl, kv);
  .)
  .

SpecCreates<.List<ActionDeclRef> creates.>
= 
  "creates" (. List<IToken> cs; .) 
  Idents<out cs> (. foreach(IToken c in cs) { creates.Add(new ActionDeclRef(c, c.val)); } .)
  ";"
  .

SpecRefinedActionForAtomicAction<ref ActionDeclRef refinedAction>
=
  (. IToken m; QKeyValue kv = null; .) 
  "refines"
  { Attribute<ref kv> }
  Ident<out m>
  (.
     if (refinedAction == null) {
        refinedAction = new ActionDeclRef(m, m.val, kv);
     } else {
        this.SemErr("a refines specification already exists");
     }
  .)
  .

SpecRefinedActionForYieldProcedure<.ref ActionDeclRef refinedAction, IToken name, List<Variable> ins, List<Variable> outs.>
=
  (. IToken tok, m; QKeyValue kv = null, akv = null; MoverType moverType = MoverType.Atomic; List<Variable> locals; StmtList stmtList; .)
  "refines"
  { Attribute<ref kv> }
  (
    [ MoverQualifier<ref moverType> ]
    "action" (. tok = t; .)
    { Attribute<ref akv> }
    Ident<out m>
    ImplBody<out locals, out stmtList>
    (.
      if (refinedAction == null) {
        var actionName = m.val == "_" ? null : m.val;
        var inParams = new List<Variable>(ins);
        inParams.RemoveAll(x => x.HasAttribute(CivlAttributes.HIDE));
        var outParams = new List<Variable>(outs);
        outParams.RemoveAll(x => x.HasAttribute(CivlAttributes.HIDE));
        var actionDecl = new ActionDecl(tok, actionName, moverType, Formal.StripWhereClauses(inParams), Formal.StripWhereClauses(outParams),
                                      false, new List<ActionDeclRef>(), null, null,
                                      new List<Requires>(), new List<CallCmd>(), new List<AssertCmd>(), new List<IdentifierExpr>(), null, akv);
        Pgm.AddTopLevelDeclaration(actionDecl);
        var impl = new Implementation(tok, actionDecl.Name, new List<TypeVariable>(), Formal.StripWhereClauses(inParams), Formal.StripWhereClauses(outParams),
                                      locals, stmtList, akv == null ? null : (QKeyValue)akv.Clone());
        Pgm.AddTopLevelDeclaration(impl);
        refinedAction = new ActionDeclRef(tok, actionDecl.Name);
      } else {
        this.SemErr("a refines specification already exists");
      }
    .)
  |
    Ident<out tok>
    (.
     if (refinedAction == null) {
        refinedAction = new ActionDeclRef(tok, tok.val, kv);
     } else {
        this.SemErr("a refines specification already exists");
     }
    .)
    ";"
  )
  .

SpecAction<.ref ActionDeclRef refinedAction, ref ActionDeclRef invariantAction, List<IdentifierExpr> mods, List<ActionDeclRef> creates, List<Requires> requires, List<CallCmd> yieldRequires, List<AssertCmd> asserts.>
=
  (
    SpecRefinedActionForAtomicAction<ref refinedAction>
    (. IToken m; .)
    ["using" Ident<out m> (. invariantAction = new ActionDeclRef(m, m.val); .)]
    ";"
  | SpecModifies<mods>
  | SpecCreates<creates>
  | SpecYieldRequires<requires, yieldRequires>
  | SpecAsserts<asserts>
  )
  .
  
MoverQualifier<ref MoverType moverType>
= (
      "left"   (. moverType = MoverType.Left; .)
    | "right"  (. moverType = MoverType.Right; .)
    | "both"   (. moverType = MoverType.Both; .)
    | "atomic" (. moverType = MoverType.Atomic; .)
  )
  .

YieldProcedureDecl<out YieldProcedureDecl ypDecl, out Implementation impl>
= (. IToken name;
     List<Variable> ins, outs = new List<Variable>();
     MoverType moverType = MoverType.None;
     ActionDeclRef refinedAction = null;
     List<Requires> pre = new List<Requires>();
     List<Ensures> post = new List<Ensures>();
     List<CallCmd> yieldRequires = new List<CallCmd>();
     List<CallCmd> yieldEnsures = new List<CallCmd>();
     List<CallCmd> yieldPreserves = new List<CallCmd>();
     List<IdentifierExpr> mods = new List<IdentifierExpr>();
     List<Variable> locals = null;
     StmtList stmtList = null;
     QKeyValue kv = null;
     impl = null;
  .)
  [ MoverQualifier <ref moverType> ]
  "procedure"
  { Attribute<ref kv> }
    Ident<out name>
    ProcFormals<true, true, out ins>
      [ "returns" ProcFormals<false, true, out outs> ]
    ( ";"
      { SpecYieldPrePost<ref refinedAction, name, ins, outs, pre, post, yieldRequires, yieldEnsures, yieldPreserves, mods> }
    | { SpecYieldPrePost<ref refinedAction, name, ins, outs, pre, post, yieldRequires, yieldEnsures, yieldPreserves, mods> }
      ImplBody<out locals, out stmtList>
      (.
         impl = new Implementation(name, name.val, new List<TypeVariable>(), Formal.StripWhereClauses(ins), Formal.StripWhereClauses(outs),
                                   locals, stmtList, kv == null ? null : (QKeyValue)kv.Clone(), this.errors);
      .)
    )
    (. ypDecl = new YieldProcedureDecl(name, name.val, moverType, ins, outs, pre, mods, post, yieldRequires, yieldEnsures, yieldPreserves, refinedAction, kv); .)
  .

SpecAsserts<. List<AssertCmd> asserts .>
= (. Expr e; Token tok; QKeyValue kv = null; .)
  "asserts"              (. tok = t; .)
  (
    { Attribute<ref kv> }
    Proposition<out e>  (. asserts.Add(new AssertCmd(tok, e, kv)); .)
  )
  ";"
  .

SpecYieldRequires<. List<Requires> pre, List<CallCmd> yieldRequires .>
= (. Expr e; Cmd cmd; Token tok; QKeyValue kv = null; .)
  "requires"              (. tok = t; .)
  ( 
    { Attribute<ref kv> }
    Proposition<out e>  (. pre.Add(new Requires(tok, false, e, null, kv)); .)
    |
    CallCmd<out cmd>        (. yieldRequires.Add((CallCmd)cmd); .)
  )
  ";"
  .

SpecYieldEnsures<. List<Ensures> post, List<CallCmd> yieldEnsures .>
= (. Expr e; Cmd cmd; Token tok; QKeyValue kv = null; .)
  "ensures"               (. tok = t; .)
  (
    { Attribute<ref kv> }
    Proposition<out e>  (. post.Add(new Ensures(tok, false, e, null, kv)); .)
    |
    CallCmd<out cmd>        (. yieldEnsures.Add((CallCmd)cmd); .)
  )
  ";"
  .

SpecYieldPreserves<. List<CallCmd> yieldPreserves .>
= (. Cmd cmd; Token tok; .)
  "preserves"             (. tok = t; .)
  CallCmd<out cmd>        (. yieldPreserves.Add((CallCmd)cmd); .)
  ";"
  .

SpecYieldPrePost<. ref ActionDeclRef refinedAction, IToken name, List<Variable> ins, List<Variable> outs, List<Requires> pre, List<Ensures> post, List<CallCmd> yieldRequires, List<CallCmd> yieldEnsures, List<CallCmd> yieldPreserves, List<IdentifierExpr> mods.>
=
  (  
    SpecRefinedActionForYieldProcedure<ref refinedAction, name, ins, outs>
  | SpecYieldRequires<pre, yieldRequires>
  | SpecYieldEnsures<post, yieldEnsures>
  | SpecYieldPreserves<yieldPreserves>
  | SpecModifies<mods>
  )
  .

Procedure<bool isPure, out Procedure proc, out /*maybe null*/ Implementation impl>
= (. Contract.Ensures(Contract.ValueAtReturn(out proc) != null); IToken x;
     List<TypeVariable> typeParams;
     List<Variable> ins, outs;
     List<Requires> pre = new List<Requires>();
     List<IdentifierExpr> mods = new List<IdentifierExpr>();
     List<Ensures> post = new List<Ensures>();
     List<Variable> locals = new List<Variable>();
     StmtList stmtList;
     QKeyValue kv = null;
     impl = null;
  .)

  "procedure"
  ProcSignature<true, out x, out typeParams, out ins, out outs, out kv>
  ( ";"
    { Spec<pre, mods, post> }
  | { Spec<pre, mods, post> }
    ImplBody<out locals, out stmtList>
    (.
      impl = new Implementation(x, x.val, typeParams.ConvertAll(tp => new TypeVariable(tp.tok, tp.Name)),
                                Formal.StripWhereClauses(ins), Formal.StripWhereClauses(outs), locals, stmtList, kv == null ? null : (QKeyValue)kv.Clone(), this.errors);
    .)
  )
  (. proc = new Procedure(x, x.val, typeParams, ins, outs, isPure, pre, mods, post, kv); .)
  .

Implementation<out Implementation impl>
= (. Contract.Ensures(Contract.ValueAtReturn(out impl) != null); IToken x;
     List<TypeVariable> typeParams;
     List<Variable> ins, outs;
     List<Variable> locals;
     StmtList stmtList;
     QKeyValue kv;
  .)

  "implementation"
  ProcSignature<false, out x, out typeParams, out ins, out outs, out kv>
  ImplBody<out locals, out stmtList>
    (. impl = new Implementation(x, x.val, typeParams, ins, outs, locals, stmtList, kv, this.errors); .)
  .


ProcSignature<.bool allowWhereClausesOnFormals, out IToken name, out List<TypeVariable> typeParams,
              out List<Variable> ins, out List<Variable> outs, out QKeyValue kv.>
= (. Contract.Ensures(Contract.ValueAtReturn(out name) != null); Contract.Ensures(Contract.ValueAtReturn(out typeParams) != null); Contract.Ensures(Contract.ValueAtReturn(out ins) != null); Contract.Ensures(Contract.ValueAtReturn(out outs) != null);
     IToken typeParamTok; typeParams = new List<TypeVariable>();
     outs = new List<Variable>(); kv = null; .)
  { Attribute<ref kv> }
  Ident<out name>
  [ TypeParams<out typeParamTok, out typeParams> ]
  ProcFormals<true, allowWhereClausesOnFormals, out ins>
  [ "returns" ProcFormals<false, allowWhereClausesOnFormals, out outs> ]
  .
  
Spec<.List<Requires> pre, List<IdentifierExpr> mods, List<Ensures> post.>
=
  (
    SpecModifies<mods>
  | "free" SpecPrePost<true, pre, post>
  | SpecPrePost<false, pre, post>
  )
  .

SpecModifies<.List<IdentifierExpr> mods.>
= (. List<IToken> ms; .)
  "modifies"
  [ Idents<out ms> (. foreach(IToken m in ms) { mods.Add(new IdentifierExpr(m, m.val)); } .) ]
  ";"
  .

SpecPrePost<.bool free, List<Requires> pre, List<Ensures> post.>
= (. Contract.Requires(pre != null); Contract.Requires(post != null); Expr e; Token tok = null; QKeyValue kv = null; .)
  ( "requires"              (. tok = t; .)
    { Attribute<ref kv> }
    Proposition<out e> ";"  (. pre.Add(new Requires(tok, free, e, null, kv)); .)
  | "ensures"               (. tok = t; .)
    { Attribute<ref kv> }
    Proposition<out e> ";"  (. post.Add(new Ensures(tok, free, e, null, kv)); .)
  )
  .

/*------------------------------------------------------------------------*/

ImplBody<.out List<Variable> locals, out StmtList stmtList.>
= (. Contract.Ensures(Contract.ValueAtReturn(out locals) != null); Contract.Ensures(Contract.ValueAtReturn(out stmtList) != null); locals = new List<Variable>(); .)
  "{"
  { LocalVars<locals> }
  StmtList<out stmtList>
  .

/* the StmtList also reads the final curly brace */
StmtList<out StmtList stmtList>
= (. Contract.Ensures(Contract.ValueAtReturn(out stmtList) != null); List<BigBlock> bigblocks = new List<BigBlock>();
     /* built-up state for the current BigBlock: */
     IToken startToken = null;  string currentLabel = null;
     List<Cmd> cs = null;  /* invariant: startToken != null ==> cs != null */
     /* temporary variables: */
     IToken label;  Cmd c;  BigBlock b;
     StructuredCmd ec = null;  StructuredCmd ecn;
     TransferCmd tc = null;  TransferCmd tcn;
  .)

  {
  ( LabelOrCmd<out c, out label>
    (. Contract.Assert(c == null || label == null);
       if (c != null) {
         // LabelOrCmd read a Cmd
         if (startToken == null) { startToken = c.tok;  cs = new List<Cmd>(); }
         Contract.Assert(cs != null);
         cs.Add(c);
       } else if (label != null) {
         // LabelOrCmd read a label
         if (startToken != null) {
           Contract.Assert(cs != null);
           // dump the built-up state into a BigBlock
           b = new BigBlock(startToken, currentLabel, cs, null, null);
           bigblocks.Add(b);
           cs = null;
         }
         startToken = label;
         currentLabel = label.val;
         cs = new List<Cmd>();
       }
    .)

  | StructuredCmd<out ecn>
    (. ec = ecn;
       if (startToken == null) { startToken = ec.tok;  cs = new List<Cmd>(); }
       Contract.Assert(cs != null);
       b = new BigBlock(startToken, currentLabel, cs, ec, null);
       bigblocks.Add(b);
       startToken = null;  currentLabel = null;  cs = null;
    .)

  | TransferCmd<out tcn>
    (. tc = tcn;
       if (startToken == null) { startToken = tc.tok;  cs = new List<Cmd>(); }
       Contract.Assert(cs != null);
       b = new BigBlock(startToken, currentLabel, cs, null, tc);
       bigblocks.Add(b);
       startToken = null;  currentLabel = null;  cs = null;
    .)

  )
  }
  "}"
  (. IToken endCurly = t;
     if (startToken == null && bigblocks.Count == 0) {
       startToken = t;  cs = new List<Cmd>();
     }
     if (startToken != null) {
       Contract.Assert(cs != null);
       b = new BigBlock(startToken, currentLabel, cs, null, null);
       bigblocks.Add(b);
     }

     stmtList = new StmtList(bigblocks, endCurly);
  .)
  .

TransferCmd<out TransferCmd tc>
= (. Contract.Ensures(Contract.ValueAtReturn(out tc) != null); tc = dummyTransferCmd;
     Token y;  List<IToken> xs;
     List<String> ss = new List<String>();
     QKeyValue kv = null;
  .)
  ( "goto"             (. y = t; .)
    { Attribute<ref kv> }
    Idents<out xs>     (. foreach(IToken s in xs){
                            Contract.Assert(s != null);
                            ss.Add(s.val); }
                          tc = new GotoCmd(y, ss) {
                            Attributes = kv
                          };
                       .)
  | "return"
    { Attribute<ref kv> }         
    (. tc = new ReturnCmd(t) { Attributes = kv }; .)
  ) ";"
  .

StructuredCmd<out StructuredCmd ec>
= (. Contract.Ensures(Contract.ValueAtReturn(out ec) != null); ec = dummyStructuredCmd;  Contract.Assume(Cce.IsPeerConsistent(ec));
     IfCmd ifcmd;  WhileCmd wcmd;  BreakCmd bcmd;
  .)
  ( IfCmd<out ifcmd>    (. ec = ifcmd; .)
  | WhileCmd<out wcmd>  (. ec = wcmd; .)
  | BreakCmd<out bcmd>  (. ec = bcmd; .)
  )
  .

IfCmd<out IfCmd ifcmd>
= (. Contract.Ensures(Contract.ValueAtReturn(out ifcmd) != null); IToken x;
     Expr guard;
     StmtList thn;
     IfCmd elseIf;  IfCmd elseIfOption = null;
     StmtList els;  StmtList elseOption = null;
     QKeyValue kv = null;
  .)
  "if"                       (. x = t; .)
  { Attribute<ref kv> }
  Guard<out guard>
  "{" StmtList<out thn>
  [ "else"
    ( IfCmd<out elseIf>      (. elseIfOption = elseIf; .)
    | "{"
      StmtList<out els>      (. elseOption = els; .)
    )
  ]
  (. ifcmd = new IfCmd(x, guard, thn, elseIfOption, elseOption, kv); .)
  .

WhileCmd<out WhileCmd wcmd>
= (. Contract.Ensures(Contract.ValueAtReturn(out wcmd) != null); IToken x;  Token z;
     Expr guard;  Expr e;  Cmd cmd;  bool isFree;
     List<PredicateCmd> invariants = new List<PredicateCmd>();
     List<CallCmd> yields = new List<CallCmd>();
     StmtList body;
     QKeyValue kv = null;
  .)
  "while"             (. x = t; .)
  Guard<out guard>    (. Contract.Assume(guard == null || Cce.Owner.None(guard)); .)
  {                   (. isFree = false; z = la/*lookahead token*/; .)
    [ "free"          (. isFree = true;  .) ]
    "invariant"
    { Attribute<ref kv> }
    (
      Expression<out e> (.
                          if (isFree) {
                            invariants.Add(new AssumeCmd(z, e, kv));
                          } else {
                            invariants.Add(new AssertCmd(z, e, kv));
                          }
						              kv = null;
                        .)
      |
      CallCmd<out cmd>  (.
                          yields.Add((CallCmd)cmd);
                          kv = null;
                        .)
    )
    ";"
  }
  "{"
  StmtList<out body>  (. wcmd = new WhileCmd(x, guard, invariants, yields, body); .)
  .

Guard<out Expr e>
= (. Expr ee;  e = null; .)
  "("
  ( "*"                   (. e = null; .)
  | Expression<out ee>    (. e = ee; .)
  )
  ")"
  .

BreakCmd<out BreakCmd bcmd>
= (.Contract.Ensures(Contract.ValueAtReturn(out bcmd) != null); IToken x;  IToken y;
     string breakLabel = null;
  .)
  "break"             (. x = t; .)
  [ Ident<out y>      (. breakLabel = y.val; .)
  ] ";"               (. bcmd = new BreakCmd(x, breakLabel); .)
  .

/*------------------------------------------------------------------------*/

LabelOrCmd<out Cmd c, out IToken label>
/* ensures (c == null) || (label == null) */
= (. IToken x; Expr e;
     List<IToken> xs;
     List<IdentifierExpr> ids;
     c = dummyCmd;  label = null;
     Cmd cn;
     QKeyValue kv = null;
     HideRevealCmd.Modes mode;
     IdentifierExpr hideRevealId = null;
  .)
  ( (
      ( "reveal" (. mode = HideRevealCmd.Modes.Reveal; .) 
      | "hide"   (. mode = HideRevealCmd.Modes.Hide;  .)
      )
      ( ident    (. hideRevealId = new IdentifierExpr(t, t.val); .)
      | "*"
      )
      (. c = hideRevealId == null ? new HideRevealCmd(t, mode) : new HideRevealCmd(hideRevealId, mode); .)
      ";"
    )
  | "pop"            (. c = new ChangeScope(t, ChangeScope.Modes.Pop); .)
    ";"
  | "push"           (. c = new ChangeScope(t, ChangeScope.Modes.Push); .)
    ";"
  | LabelOrAssign<out c, out label>
  | "assert"              (. x = t; .)
    { Attribute<ref kv> }
    Proposition<out e>    (. c = new AssertCmd(x, e, kv); .)
    ";"
  | "assume"              (. x = t; .)
    { Attribute<ref kv> }
    Proposition<out e>    (. c = new AssumeCmd(x, e, kv); .)
    ";"
  | "havoc"               (. x = t; .)
    Idents<out xs> ";"    (. ids = new List<IdentifierExpr>();
                             foreach(IToken y in xs){
                               Contract.Assert(y != null);
                               ids.Add(new IdentifierExpr(y, y.val));
                             }
                             c = new HavocCmd(x,ids);
                          .)
  | CallCmd<out cn> ";"   (. c = cn; .)
  | ParCallCmd<out cn>    (. c = cn; .)
  )
  .

/*------------------------------------------------------------------------*/

LabelOrAssign<out Cmd c, out IToken label>
/* ensures (c == null) != (label != null) */
= (. IToken id; IToken x, y; Expr e0; List<IToken> ids;
     c = dummyCmd;  label = null;
     AssignLhs lhs;
     List<AssignLhs> lhss;
     List<Expr> rhss;
     List<Expr> indexes;
     FieldAccess fieldAccess;
     QKeyValue kv = null;
     NAryExpr lhsExpr;
  .)
  Ident<out id>              (. x = t; .)
  ( ":"                      (. c = null; label = x; .)

  | "(" Idents<out ids> ")"
    (.
      lhsExpr = new NAryExpr(x, new FunctionCall(new IdentifierExpr(id, id.val)), ids.Select(id => new IdentifierExpr(id, id.val)).ToList<Expr>());
    .)
    ":=" (. x = t; /* use location of := */ .)
    { Attribute<ref kv> }
    Expression<out e0>
    ";"
    (.
       c = new UnpackCmd(x, lhsExpr, e0, kv);
    .)

  | (. lhss = new List<AssignLhs>(); .)
    (. lhs = new SimpleAssignLhs(id, new IdentifierExpr(id, id.val)); .)

    {
      MapAssignIndex<out y, out indexes>  (. lhs = new MapAssignLhs(y, lhs, indexes); .)
      |
      FieldAccess<out y, out fieldAccess> (. lhs = new FieldAssignLhs(y, lhs, fieldAccess); .)
    }
    (. lhss.Add(lhs); .)

    { ","
      Ident<out id>
      (. lhs = new SimpleAssignLhs(id, new IdentifierExpr(id, id.val)); .)
      {
        MapAssignIndex<out y, out indexes>    (. lhs = new MapAssignLhs(y, lhs, indexes); .)
        |
        FieldAccess<out y, out fieldAccess> (. lhs = new FieldAssignLhs(y, lhs, fieldAccess); .)
      }
      (. lhss.Add(lhs); .)
    }

    ":="                     (. x = t; /* use location of := */ .)
    { Attribute<ref kv> }
    Expression<out e0>       (. rhss = new List<Expr> ();
                                rhss.Add(e0); .)
    { ","
      Expression<out e0>     (. rhss.Add(e0); .)
    }
    ";"                      (. c = new AssignCmd(x, lhss, rhss, kv); .)
  )
  .

MapAssignIndex<.out IToken x, out List<Expr> indexes.>
= (.Contract.Ensures(Contract.ValueAtReturn(out x) != null); Contract.Ensures(Cce.NonNullElements(Contract.ValueAtReturn(out indexes))); indexes = new List<Expr> ();
     Expr e;
  .)
  "["                        (. x = t; .)
    [
      Expression<out e>      (. indexes.Add(e); .)
      { ","
        Expression<out e>    (. indexes.Add(e); .)
      }
    ]
  "]"
  .

FieldAccess<.out IToken x, out FieldAccess fieldAccess.>
= (. Contract.Ensures(Contract.ValueAtReturn(out fieldAccess) != null); IToken id; .)
  "->" (. x = t; .)
  Ident<out id> (. fieldAccess = new FieldAccess(id, id.val); .)
  .

/*------------------------------------------------------------------------*/
CallCmd<out Cmd c>
= (. Contract.Ensures(Contract.ValueAtReturn(out c) != null);
     IToken x;
     bool isAsync = false;
     bool isFree = false;
     c = null;
  .)
  [ "async" (. isAsync = true; .) ]
  [ "free"  (. isFree = true; .) ]
  "call"                          (. x = t; .)
  CallParams<isAsync, isFree, x, out c> (. .)
  .

ParCallCmd<out Cmd d>
= (.
    Contract.Ensures(Contract.ValueAtReturn(out d) != null);
    IToken x;
    Cmd c = null;
    List<CallCmd> callCmds = new List<CallCmd>();
  .)
  "par"                          (. x = t; .)
  CallParams<false, false, x, out c> (. callCmds.Add((CallCmd)c); .)
  { "|" CallParams<false, false, x, out c> (. callCmds.Add((CallCmd)c); .)
  }
  ";" (. d = new ParCallCmd(x, callCmds); .)
  .

CallParams<bool isAsync, bool isFree, IToken x, out Cmd c>
= (.
    QKeyValue kv = null;
    List<IdentifierExpr> ids = new List<IdentifierExpr>();
    List<Expr> es = new List<Expr>();
    Expr en;
    IToken first;
    IToken p;
	c = null;
  .)
  { Attribute<ref kv> }
  Ident<out first>
    ( "("
      [ Expression<out en>       (. es.Add(en); .)
        { "," Expression<out en> (. es.Add(en); .)
        }
      ]
      ")"                         (. c = new CallCmd(x, first.val, es, ids, kv); ((CallCmd) c).IsFree = isFree; ((CallCmd) c).IsAsync = isAsync; .)
    |
                                  (. ids.Add(new IdentifierExpr(first, first.val)); .)
      [ "," Ident<out p>  (. ids.Add(new IdentifierExpr(p, p.val)); .)
        { "," Ident<out p>  (. ids.Add(new IdentifierExpr(p, p.val)); .)
        }
      ] ":="
      Ident<out first> "("
      [ Expression<out en>       (. es.Add(en); .)
        { "," Expression<out en> (. es.Add(en); .)
        }
      ]
      ")"                         (. c = new CallCmd(x, first.val, es, ids, kv); ((CallCmd) c).IsFree = isFree; ((CallCmd) c).IsAsync = isAsync; .)
    )
  .

/*------------------------------------------------------------------------*/
Proposition<out Expr e>
=(.Contract.Ensures(Contract.ValueAtReturn(out e) != null);.)
  Expression<out e>
  .

/*------------------------------------------------------------------------*/
Idents<.out List<IToken> xs.>
= (.Contract.Ensures(Contract.ValueAtReturn(out xs) != null); IToken id; xs = new List<IToken>(); .)
  Ident<out id>                 (. xs.Add(id); .)
  { "," Ident<out id>           (. xs.Add(id); .)
  }
  .

/*------------------------------------------------------------------------*/
WhiteSpaceIdents<.out List<IToken> xs.>
= (. Contract.Ensures(Contract.ValueAtReturn(out xs) != null); IToken id; xs = new List<IToken>(); .)
  Ident<out id>                 (. xs.Add(id); .)
  { Ident<out id>               (. xs.Add(id); .)
  }
  .

/*------------------------------------------------------------------------*/
Expressions<.out List<Expr> es.>
= (. Contract.Ensures(Contract.ValueAtReturn(out es) != null); Expr e; es = new List<Expr>(); .)
  Expression<out e>             (. es.Add(e); .)
  { "," Expression<out e>       (. es.Add(e); .)
  }
  .

/*------------------------------------------------------------------------*/
Expression<.out Expr e0.>
= (. Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken x; Expr e1; .)
  ImpliesExpression<false, out e0>
  { EquivOp        (. x = t; .)
    ImpliesExpression<false, out e1>
                   (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Iff, e0, e1); .)
  }
  .

EquivOp = "<==>" | '\u21d4'.

/*------------------------------------------------------------------------*/
ImpliesExpression<bool noExplies, out Expr e0>
= (. Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken x; Expr e1; .)
  LogicalExpression<out e0>
  [
    ImpliesOp      (. x = t; .)
    /* recurse because implication is right-associative */
    ImpliesExpression<true, out e1>
                   (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Imp, e0, e1); .)
  |
    ExpliesOp      (. if (noExplies)
                        this.SemErr("illegal mixture of ==> and <==, use parentheses to disambiguate");
                      x = t; .)
    LogicalExpression<out e1>
                   (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Imp, e1, e0); .)
    /* loop because explies is left-associative */
    {
      ExpliesOp    (. x = t; .)
      LogicalExpression<out e1>
                   (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Imp, e1, e0); .)
    }
  ]
  .

ImpliesOp = "==>" | '\u21d2'.
ExpliesOp = "<==" | '\u21d0'.

/*------------------------------------------------------------------------*/
LogicalExpression<out Expr e0>
= (. Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken x; Expr e1; .)
  RelationalExpression<out e0>
  [ AndOp          (. x = t; .)
    RelationalExpression<out e1>
    (. e0 = Expr.Binary(x, BinaryOperator.Opcode.And, e0, e1); .)
    { AndOp        (. x = t; .)
      RelationalExpression<out e1>
      (. e0 = Expr.Binary(x, BinaryOperator.Opcode.And, e0, e1); .)
    }
  | OrOp           (. x = t; .)
    RelationalExpression<out e1>
    (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Or, e0, e1); .)
    { OrOp         (. x = t; .)
      RelationalExpression<out e1>
      (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Or, e0, e1); .)
    }
  ]
  .

AndOp = "&&" | '\u2227'.
OrOp = "||" | '\u2228'.

/*------------------------------------------------------------------------*/
RelationalExpression<out Expr e0>
= (. Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken x; Expr e1; BinaryOperator.Opcode op; .)
  BvTerm<out e0>
  [ RelOp<out x, out op>
    BvTerm<out e1>            (. e0 = Expr.Binary(x, op, e0, e1); .)
  ]
  .

RelOp<out IToken x, out BinaryOperator.Opcode op>
=                  (.Contract.Ensures(Contract.ValueAtReturn(out x) != null); x = Token.NoToken; op=BinaryOperator.Opcode.Add/*(dummy)*/; .)
  ( "=="           (. x = t; op=BinaryOperator.Opcode.Eq; .)
  | "<"            (. x = t; op=BinaryOperator.Opcode.Lt; .)
  | ">"            (. x = t; op=BinaryOperator.Opcode.Gt; .)
  | "<="           (. x = t; op=BinaryOperator.Opcode.Le; .)
  | ">="           (. x = t; op=BinaryOperator.Opcode.Ge; .)
  | "!="           (. x = t; op=BinaryOperator.Opcode.Neq; .)
  | '\u2260'       (. x = t; op=BinaryOperator.Opcode.Neq; .)
  | '\u2264'       (. x = t; op=BinaryOperator.Opcode.Le; .)
  | '\u2265'       (. x = t; op=BinaryOperator.Opcode.Ge; .)
  )
  .

/*------------------------------------------------------------------------*/
BvTerm<out Expr e0>
= (. Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken x; Expr e1; .)
  Term<out e0>
  { "++"                  (. x = t; .)
    Term<out e1>          (. e0 = new BvConcatExpr(x, e0, e1); .)
  }
  .


/*------------------------------------------------------------------------*/
Term<out Expr e0>
= (.Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken x; Expr e1; BinaryOperator.Opcode op; .)
  Factor<out e0>
  { AddOp<out x, out op>
    Factor<out e1>          (. e0 = Expr.Binary(x, op, e0, e1); .)
  }
  .

AddOp<out IToken x, out BinaryOperator.Opcode op>
=                  (.Contract.Ensures(Contract.ValueAtReturn(out x) != null); x = Token.NoToken; op=BinaryOperator.Opcode.Add/*(dummy)*/; .)
  ( "+"            (. x = t; op=BinaryOperator.Opcode.Add; .)
  | "-"            (. x = t; op=BinaryOperator.Opcode.Sub; .)
  )
  .

/*------------------------------------------------------------------------*/
Factor<out Expr e0>
= (.Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken x; Expr e1; BinaryOperator.Opcode op; .)
  Power<out e0>
  { MulOp<out x, out op>
    Power<out e1> (. e0 = Expr.Binary(x, op, e0, e1); .)
  }
  .

MulOp<out IToken x, out BinaryOperator.Opcode op>
=                  (. Contract.Ensures(Contract.ValueAtReturn(out x) != null); x = Token.NoToken; op=BinaryOperator.Opcode.Add/*(dummy)*/; .)
  ( "*"            (. x = t; op=BinaryOperator.Opcode.Mul; .)
  | "div"          (. x = t; op=BinaryOperator.Opcode.Div; .)
  | "mod"          (. x = t; op=BinaryOperator.Opcode.Mod; .)
  | "/"            (. x = t; op=BinaryOperator.Opcode.RealDiv; .)
  )
  .

/*------------------------------------------------------------------------*/
Power<out Expr e0>
= (.Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken x; Expr e1; .)
  IsConstructor<out e0>
  [
    "**"           (. x = t; .)
    /* recurse because exponentation is right-associative */
    Power<out e1>  (. e0 = Expr.Binary(x, BinaryOperator.Opcode.Pow, e0, e1); .)
  ]
  .

IsConstructor<out Expr e0>
= (. Contract.Ensures(Contract.ValueAtReturn(out e0) != null); IToken x, id; .)
  UnaryExpression<out e0>
  [ "is"            (. x = t; .)
    Ident<out id>
    (. var isConstructor = new IsConstructor(id, id.val);
       e0 = new NAryExpr(x, isConstructor, new List<Expr> { e0 });
    .)
  ]
  .

/*------------------------------------------------------------------------*/
UnaryExpression<out Expr e>
= (. Contract.Ensures(Contract.ValueAtReturn(out e) != null); IToken x;
     e = dummyExpr;
  .)
  ( "-"                        (. x = t; .)
    UnaryExpression<out e>     (. e = Expr.Unary(x, UnaryOperator.Opcode.Neg, e); .)
  | NegOp                      (. x = t; .)
    UnaryExpression<out e>     (. e = Expr.Unary(x, UnaryOperator.Opcode.Not, e); .)
  | CoercionExpression<out e>
  )
  .

NegOp = "!" | '\u00ac'.

/*------------------------------------------------------------------------*/

/* This production creates ambiguities, because types can start with "<"
   (polymorphic map types), but can also be followed by "<" (inequalities).
   Coco deals with these ambiguities in a reasonable way by preferring to read
   further types (type arguments) over relational symbols. E.g., "5 : C < 0"
   will cause a parse error because "<" is treated as the beginning of a
   map type. */

CoercionExpression<out Expr e>
= (. Contract.Ensures(Contract.ValueAtReturn(out e) != null); IToken x;
     Bpl.Type coercedTo;
     BigNum bn;
    .)
  ArrayExpression<out e>
  { ":"                     (. x = t; .)
    (
      Type<out coercedTo>   (. e = Expr.CoerceType(x, e, coercedTo); .)
    |
      Nat<out bn>           /* This means that we really look at a bitvector
                               expression t[a:b] */
                            (. if (!(e is LiteralExpr) || !((LiteralExpr)e).isBigNum) {
                                 this.SemErr("arguments of extract need to be integer literals");
                                 e = new BvBounds(x, bn, BigNum.ZERO);
                               } else {
                                 e = new BvBounds(x, bn, ((LiteralExpr)e).asBigNum);
                               }
                             .)
    )
  }
  .

/*------------------------------------------------------------------------*/
ArrayExpression<out Expr e>
= (. Contract.Ensures(Contract.ValueAtReturn(out e) != null);
     IToken x, id;
     Expr index0 = dummyExpr; Expr e1;
     bool store; bool bvExtract;
     List<Expr> allArgs = dummyExprSeq;
  .)
  AtomExpression<out e>
  { "["        (. x = t; allArgs = new List<Expr> ();
                  allArgs.Add(e);
                  store = false; bvExtract = false; .)
      [
        Expression<out index0>
               (. if (index0 is BvBounds)
                    bvExtract = true;
                  else
                    allArgs.Add(index0);
               .)
        { "," Expression<out e1>
               (. if (bvExtract || e1 is BvBounds)
                    this.SemErr("bitvectors only have one dimension");
                  allArgs.Add(e1);
               .)
        }
        [ ":=" Expression<out e1>
               (. if (bvExtract || e1 is BvBounds)
                    this.SemErr("assignment to bitvectors is not possible");
                  allArgs.Add(e1); store = true;
               .)
        ]
      | ":=" Expression<out e1>       (. allArgs.Add(e1); store = true; .)
      ]
    "]"
    (. if (store)
         e = new NAryExpr(x, new MapStore(x, allArgs.Count - 2), allArgs);
       else if (bvExtract)
         e = new BvExtractExpr(x, e,
                               ((BvBounds)index0).Upper.ToIntSafe,
                               ((BvBounds)index0).Lower.ToIntSafe);
       else
         e = new NAryExpr(x, new MapSelect(x, allArgs.Count - 1), allArgs);
    .)
    |
      "->" (. x = t; .)
      (
        Ident<out id> (. e = new NAryExpr(x, new FieldAccess(id, id.val), new List<Expr> { e }); .)
        |
        "("
        Ident<out id>
        ":=" (. x = t; .)
        Expression<out e1>
        ")" (. e = new NAryExpr(x, new FieldUpdate(id, id.val), new List<Expr> { e, e1 }); .)
      )
  }
  .

/*------------------------------------------------------------------------*/
AtomExpression<out Expr e>
= (. Contract.Ensures(Contract.ValueAtReturn(out e) != null); IToken x; int n; BigNum bn; BigDec bd; BigFloat bf;
     List<Expr> es;  List<Variable> ds;  Trigger trig;
     List<TypeVariable> typeParams;
     IdentifierExpr id;
     QKeyValue kv;
     e = dummyExpr;
     List<Variable> locals;
     List<Block> blocks;
  .)
  ( "false"           (. e = new LiteralExpr(t, false); .)
  | "true"            (. e = new LiteralExpr(t, true); .)
  | ("roundNearestTiesToEven" | "RNE")    (. e = new LiteralExpr(t, RoundingMode.RNE); .)
  | ("roundNearestTiesToAway" | "RNA")    (. e = new LiteralExpr(t, RoundingMode.RNA); .)
  | ("roundTowardPositive" | "RTP")       (. e = new LiteralExpr(t, RoundingMode.RTP); .)
  | ("roundTowardNegative" | "RTN")       (. e = new LiteralExpr(t, RoundingMode.RTN); .)
  | ("roundTowardZero" | "RTZ")           (. e = new LiteralExpr(t, RoundingMode.RTZ); .)
  | Nat<out bn>            (. e = new LiteralExpr(t, bn); .)
  | Dec<out bd>            (. e = new LiteralExpr(t, bd); .)
		| Float<out bf>            (. e = new LiteralExpr(t, bf); .)
  | BvLit<out bn, out n> (. e = new LiteralExpr(t, bn, n); .)
  | string                  (. e = new LiteralExpr(t, t.val.Trim('"')); .)

  | Ident<out x>            (. id = new IdentifierExpr(x, x.val);  e = id; .)
    [ "("
      ( Expressions<out es> (. e = new NAryExpr(x, new FunctionCall(id), es); .)
      | /* empty */         (. e = new NAryExpr(x, new FunctionCall(id), new List<Expr>()); .)
      )
      ")"
    ]

  | "old"                   (. x = t; .)
    "("
    Expression<out e>
    ")"                     (. e = new OldExpr(x, e); .)

  | "int"                   (. x = t; .)
    "("
    Expression<out e>
    ")"                     (. e = new NAryExpr(x, new ArithmeticCoercion(x, ArithmeticCoercion.CoercionType.ToInt), new List<Expr>{ e }); .)

  | "real"                  (. x = t; .)
    "("
    Expression<out e>
    ")"                     (. e = new NAryExpr(x, new ArithmeticCoercion(x, ArithmeticCoercion.CoercionType.ToReal), new List<Expr>{ e }); .)

  | "(" ( Expression<out e>                 (. if (e is BvBounds)
                                                 this.SemErr("parentheses around bitvector bounds are not allowed"); .)
        | Forall                            (. x = t; .)
          QuantifierBody<x, out typeParams, out ds, out kv, out trig, out e>
                                            (. if (typeParams.Count + ds.Count > 0)
                                                 e = new ForallExpr(x, typeParams, ds, kv, trig, e); .)
        | Exists                            (. x = t; .)
          QuantifierBody<x, out typeParams, out ds, out kv, out trig, out e>
                                            (. if (typeParams.Count + ds.Count > 0)
                                                 e = new ExistsExpr(x, typeParams, ds, kv, trig, e); .)
        | Lambda                            (. x = t; .)
          QuantifierBody<x, out typeParams, out ds, out kv, out trig, out e>
                                            (. if (trig != null)
                                                 SemErr("triggers not allowed in lambda expressions");
                                               if (typeParams.Count + ds.Count > 0)
                                                 e = new LambdaExpr(x, typeParams, ds, kv, e); .)
        | LetExpr<out e>
        )
    ")"
  | IfThenElseExpression<out e>
  | CodeExpression<out locals, out blocks> (. e = new CodeExpr(locals, blocks); .)
  )
  .

CodeExpression<.out List<Variable> locals, out List<Block> blocks.>
= (. Contract.Ensures(Contract.ValueAtReturn(out locals) != null); Contract.Ensures(Cce.NonNullElements(Contract.ValueAtReturn(out blocks))); locals = new List<Variable>(); Block b;
     blocks = new List<Block>();
  .)
  "|{"
  { LocalVars<locals> }
  SpecBlock<out b>          (. blocks.Add(b); .)
  { SpecBlock<out b>        (. blocks.Add(b); .)
  }
  "}|"
  .

SpecBlock<out Block b>
= (. Contract.Ensures(Contract.ValueAtReturn(out b) != null); IToken x; IToken y;
     Cmd c;  IToken label;
     List<Cmd> cs = new List<Cmd>();
     List<IToken> xs;
     List<String> ss = new List<String>();
     b = dummyBlock;
     QKeyValue kv = null;
     Expr e;
  .)
  Ident<out x> ":"
  { LabelOrCmd<out c, out label>
                       (. Contract.Assert(c == null || label == null);
                          if (c != null) {
                            cs.Add(c);
                          } else if (label != null) {
                            SemErr("SpecBlock's can only have one label");
                          }
                       .)
  }
  ( "goto"             (. y = t; .)
    { Attribute<ref kv> }
    Idents<out xs>     (. foreach(IToken s in xs){
                            Contract.Assert(s != null);
                            ss.Add(s.val); }
                          b = new Block(x,x.val,cs,new GotoCmd(y,ss) {
                            Attributes = kv
                          });
                       .)
  | "return" 
    { Attribute<ref kv> }
    Expression<out e>
                       (. b = new Block(x,x.val,cs,new ReturnExprCmd(t,e) {
                            Attributes = kv
                          }); 
                       .)
  )
  ";"
  .

Attribute<ref QKeyValue kv>
= (. Trigger trig = null; .)
  AttributeOrTrigger<ref kv, ref trig> (.  if (trig != null) this.SemErr("only attributes, not triggers, allowed here"); .)
.

AttributeOrTrigger<ref QKeyValue kv, ref Trigger trig>
= (. IToken tok;  Expr e;  List<Expr> es;
     IToken id;
     List<object> parameters;  object param;
  .)
  "{"                                         (. tok = t; .)
     (
       ":" Ident<out id>                      (. parameters = new List<object>(); .)
       [ AttributeParameter<out param>        (. parameters.Add(param); .)
         { "," AttributeParameter<out param>  (. parameters.Add(param); .)
         }
       ]
       (. if (id.val == "nopats") {
            if (parameters.Count == 1 && parameters[0] is Expr) {
              e = (Expr)parameters[0];
              if(trig==null){
                trig = new Trigger(tok, false, new List<Expr> { e }, null);
              } else {
                trig.AddLast(new Trigger(tok, false, new List<Expr> { e }, null));
              }
            } else {
              this.SemErr("the 'nopats' quantifier attribute expects a string-literal parameter");
            }
          } else {
            if (kv==null) {
              kv = new QKeyValue(tok, id.val, parameters, null);
            } else {
              kv.AddLast(new QKeyValue(tok, id.val, parameters, null));
            }
          }
       .)
     |
       Expression<out e>       (. es = new List<Expr> { e }; .)
       { "," Expression<out e> (. es.Add(e); .)
       }                       (. if (trig==null) {
                                    trig = new Trigger(tok, true, es, null);
                                  } else {
                                    trig.AddLast(new Trigger(tok, true, es, null));
                                  }
                               .)
     )
  "}"
  .

AttributeParameter<out object o>
= (. Contract.Ensures(Contract.ValueAtReturn(out o) != null);
     o = "error";
     Expr e;
  .)
  ( string                (. o = t.val.Substring(1, t.val.Length-2); .)
  | Expression<out e>     (. o = e; .)
  )
  .

IfThenElseExpression<out Expr e>
= (. Contract.Ensures(Contract.ValueAtReturn(out e) != null);
     IToken tok;
     Expr e0, e1, e2;
     e = dummyExpr; .)
  "if" (. tok = t; .) Expression<out e0> "then" Expression<out e1> "else" Expression<out e2>
  (. e = new NAryExpr(tok, new IfThenElse(tok), new List<Expr>{ e0, e1, e2 }); .)
  .


QuantifierBody<.IToken q, out List<TypeVariable> typeParams, out List<Variable> ds,
               out QKeyValue kv, out Trigger trig, out Expr body.>
= (. Contract.Requires(q != null); Contract.Ensures(Contract.ValueAtReturn(out typeParams) != null); Contract.Ensures(Contract.ValueAtReturn(out ds) != null); Contract.Ensures(Contract.ValueAtReturn(out body) != null);
     trig = null; typeParams = new List<TypeVariable> ();
     IToken tok;
     kv = null;
     ds = new List<Variable> ();
  .)
  (
     TypeParams<out tok, out typeParams>
     [ BoundVars<out ds> ]
  |
     BoundVars<out ds>
  )
  QSep
  { AttributeOrTrigger<ref kv, ref trig> }
  Expression<out body>
  .

Forall = "forall" | '\u2200'.
Exists = "exists" | '\u2203'.
Lambda = "lambda" | '\u03bb'.
QSep = "::" | '\u2022'.

LetExpr<.out Expr letexpr.>
= (. IToken tok;
     Variable v;
     var ds = new List<Variable>();
     Expr e0;
     var rhss = new List<Expr>();
     QKeyValue kv = null;
     Expr body;
  .)
  "var"                    (. tok = t; .)
  LetVar<out v>            (. ds.Add(v); .)
  { ","
    LetVar<out v>          (. ds.Add(v); .)
  }
  ":="
  Expression<out e0>       (. rhss.Add(e0); .)
  { ","
    Expression<out e0>     (. rhss.Add(e0); .)
  }
  ";"
  { Attribute<ref kv> }
  Expression<out body>     (. letexpr = new LetExpr(tok, ds, rhss, kv, body); .)
  .

LetVar<.out Variable v.>
= (. QKeyValue kv = null;
     IToken id;
  .)
  { Attribute<ref kv> }
  Ident<out id>
  (.
    var tyd = new TypedIdent(id, id.val, dummyType/*will be replaced during type checking*/, null);
    v = new BoundVariable(tyd.tok, tyd, kv);
  .)
  .

/*------------------------------------------------------------------------*/
Ident<out IToken x>
=(.Contract.Ensures(Contract.ValueAtReturn(out x) != null);.)
  ( ident
  | "atomic"   (. t.kind = _ident; .) // convert to ident
  | "both"     (. t.kind = _ident; .) // convert to ident
  | "left"     (. t.kind = _ident; .) // convert to ident
  | "right"    (. t.kind = _ident; .) // convert to ident
  | "reveal"     (. t.kind = _ident; .) // convert to ident
  | "hide"     (. t.kind = _ident; .) // convert to ident
  | "push"     (. t.kind = _ident; .) // convert to ident
  | "pop"     (. t.kind = _ident; .) // convert to ident
  )
  (.
    x = t;
    if (x.val.StartsWith("\\"))
      x.val = x.val.Substring(1);
  .)
  .

/*------------------------------------------------------------------------*/
Nat<out BigNum n>
=
  digits
  (. try {
       n = BigNum.FromString(t.val);
     } catch (FormatException) {
       this.SemErr("incorrectly formatted number");
       n = BigNum.ZERO;
     }
  .)
  .

/*------------------------------------------------------------------------*/
Dec<out BigDec n>
= (. string s = ""; .)
  (
    decimal   (. s = t.val; .)
  |
    dec_float     (. s = t.val; .)
  )
  (. try {
       n = BigDec.FromString(s);
     } catch (FormatException) {
       this.SemErr("incorrectly formatted number");
       n = BigDec.ZERO;
     }
  .)
  .

/*------------------------------------------------------------------------*/
BvLit<out BigNum n, out int m>
=
  bvlit
  (.
     int pos = t.val.IndexOf("bv");
     string a = t.val.Substring(0, pos);
     string b = t.val.Substring(pos + 2);
     try {
       n = BigNum.FromString(a);
       m = Convert.ToInt32(b);
     } catch (FormatException) {
       this.SemErr("incorrectly formatted bitvector");
       n = BigNum.ZERO;
       m = 0;
     }
  .)
  .

Float<out BigFloat n>
= (. string s = ""; .)
  (
    float   (. s = t.val; .)
  )
  (. try {
       n = BigFloat.FromString(s);
     } catch (FormatException e) {
       this.SemErr("incorrectly formatted floating point, " + e.Message);
       n = BigFloat.ZERO;
     }
  .)
  .

END BoogiePL.
